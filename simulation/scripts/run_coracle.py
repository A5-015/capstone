#!/usr/bin/env python

"""Runs the Coracle simulator using the configuration file
generated by sim_config_json.py and visualizes the result as a PDF report
"""

import os
import sys
import json
import base64
import argparse
import subprocess
import numpy as np
import pandas as pd
from tqdm import tqdm
import plotly.graph_objects as go
from collections import defaultdict


class Visualizer:
    def __init__(self):
        self.raw_results = []
        self.raw_dictionary = defaultdict(list)

    def _parse(self, result):
        # Store in ordered dictionary for easy retrieval
        for key, value in result.items():
            # Recurse to get to bottom of JSON tree
            if type(value) is dict:
                self._parse(value)
            else:
                # Only store statistics
                if key != "figures" and type(value) != str:
                    self.raw_dictionary[key].append(value)

    def _generate_statistics(self):

        num_attributes = len(self.raw_dictionary)

        self.statistics_dataframe = pd.DataFrame(
            np.zeros((num_attributes, 2)),
            columns=["Mean", "Variance"],
            index=self.raw_dictionary.keys(),
        )

        for key, value in self.raw_dictionary.items():
            self.statistics_dataframe.loc[key, :][0] = np.mean(value)
            self.statistics_dataframe.loc[key, :][1] = np.var(value)

    def initialize(self, all_runs):
        # Filter out to keep only results key in each run
        for run in all_runs:
            for key, value in run.items():
                if key == "results":
                    self.raw_results.append(value)
                    self._parse(value)

    def generate_pdf(self):
        self._generate_statistics()
        fig = go.Figure(
            data=[
                go.Table(
                    header=dict(
                        values=list(["Attributes"])
                        + list(self.statistics_dataframe.columns)
                    ),
                    cells=dict(
                        values=[
                            self.statistics_dataframe.index,
                            self.statistics_dataframe.Mean,
                            self.statistics_dataframe.Variance,
                        ]
                    ),
                )
            ]
        )
        fig.show()


def main(arguments):

    default_docker_image = "ghcr.io/a5-015/ramen/ramen-sim:docker"

    # Argument parsing
    parser = argparse.ArgumentParser(
        description=__doc__, formatter_class=argparse.RawDescriptionHelpFormatter
    )
    parser.add_argument("-i", "--infile", help="Input file", required=True)
    parser.add_argument(
        "-d", "--docker", help="Docker image to use", default=default_docker_image
    )
    parser.add_argument(
        "-e", "--experiments", help="Number of experiments to run", type=int, default=3
    )
    args = parser.parse_args(arguments)

    simulation_results = []
    with open(args.infile) as file:
        # Import the JSON file contents
        data = json.load(file)

        # Encode network simulation data into base64
        encoded_json = base64.b64encode(json.dumps(data).encode()).decode()

        # Construct the command chain for e loops
        command = (
            "sudo docker run %s /bin/bash -c 'for i in {1..%s}; do python3 base64_to_json.py %s > network.json; ./coracle/coracle_sim.byte -f network.json; echo; done'"
            % (args.docker, args.experiments, encoded_json)
        )

        # Run the simulation(s) process
        process = subprocess.Popen(
            ["/bin/bash", "-c", command],
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
        )

        # Start a progress bar
        with tqdm(total=args.experiments, desc="Running simulations...") as pbar:
            while process.poll() is None:
                line = process.stdout.readline()
                if line != b"" and line != b"\n":
                    pbar.update(1)
                    simulation_results.append(line)

    # Strip each result of a newline character using list comprehension
    simulation_results = [
        json.loads(result.strip().decode()) for result in simulation_results
    ]

    # print(simulation_results[0])

    # with open(args.infile) as file:
    #     simulation_results = json.load(file)

    visualizer = Visualizer()
    visualizer.initialize(simulation_results)
    visualizer.generate_pdf()


if __name__ == "__main__":
    sys.exit(main(sys.argv[1:]))
